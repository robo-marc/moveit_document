# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, National Institute of Advanced Industrial Science and
# Technology
# This file is distributed under the same license as the NEDO ROBO-MARC
# MoveIt! Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: NEDO ROBO-MARC MoveIt! Documentation 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-01-29 19:12+0900\n"
"PO-Revision-Date: 2020-01-31 14:07+0900\n"
"Last-Translator: Yosuke Matsusaka <yosuke.matsusaka@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: /home/yosuke/moveit_document/source/planning_scene.rst:2
msgid "プランニングシーン（PlanningScene）の仕様"
msgstr ""

msgid ""
"This class maintains the representation of the environment as seen by a "
"planning instance. The environment geometry, the robot geometry and state "
"are maintained."
msgstr "このクラスは、プランナーから見たワールドを管理します。環境形状、ロボット形状、および状態が格納されます。"

msgid ""
"Inherits from noncopyable, std::enable_shared_from_this< PlanningScene >"
msgstr ""

msgid "Reasoning about frames"
msgstr "基準座標に対する処理"

msgid "Get the frame in which planning is performed."
msgstr "計画が実行される基準座標を取得します。"

msgid ""
"Get the set of fixed transforms from known frames to the planning frame."
msgstr "既知の基準座標から計画で用いられる基準座標への変換を取得します。"

msgid ""
"Get the set of fixed transforms from known frames to the planning frame. "
"This variant is non-const and also updates the current state."
msgstr "既知の基準座標から計画で用いられる基準座標への変換を取得します。"
"このバリアントはconstでは無いため、現在の状態も更新します。"

msgid ""
"Get the transform corresponding to the frame id. This will be known if id is"
" a link name, an attached body id or a collision object. Return identity "
"when no transform is available. Use knowsFrameTransform() to test if this "
"function will be successful or not."
msgstr ""
"基準座標IDに対応する変換を取得します。"
"これは、IDがリンク名、接続された剛体のID、または干渉オブジェクトである場合に有効です。"
"変換が使用できない場合はIDを返します。"
"knowsFrameTransform()を使用して、この関数が成功するかどうかをテストできます。"

msgid ""
"Get the transform corresponding to the frame id. This will be known if id is"
" a link name, an attached body id or a collision object. Return identity "
"when no transform is available. Use knowsFrameTransform() to test if this "
"function will be successful or not. Because this function is non-const, the "
"current state transforms are also updated, if needed."
msgstr ""
"基準座標IDに対応する変換を取得します。"
"これは、IDがリンク名、接続された剛体のID、または干渉オブジェクトである場合に有効です。"
"変換が使用できない場合はIDを返します。"
"knowsFrameTransform()を使用して、この関数が成功するかどうかをテストできます。"
"この関数はconstでないため、現在の変換も更新できます。"

msgid ""
"Get the transform corresponding to the frame id. This will be known if id is"
" a link name, an attached body id or a collision object. Return identity "
"when no transform is available. Use knowsFrameTransform() to test if this "
"function will be successful or not. This function also updates the link "
"transforms of state."
msgstr ""
"基準座標IDに対応する変換を取得します。"
"これは、IDがリンク名、接続された剛体のID、または干渉オブジェクトである場合に有効です。"
"変換が使用できない場合はIDを返します。"
"knowsFrameTransform()を使用して、この関数が成功するかどうかをテストできます。"
"この関数は、stateのリンク座標も更新します。"

msgid ""
"Check if a transform to the frame id is known. This will be known if id is a"
" link name, an attached body id or a collision object."
msgstr ""
"基準座標IDへの変換が既知かどうかを確認します。"
"これは、IDがリンク名、接続された剛体のID、または干渉オブジェクトである場合に有効です。"

msgid "Reasoning about the geometry of the planning scene"
msgstr "planning sceneの形状に対する処理"

msgid "Add a new collision detector type."
msgstr "新しい干渉検出器を追加します。"

msgid ""
"A collision detector type is specified with (a shared pointer to) an "
"allocator which is a subclass of CollisionDetectorAllocator. This identifies"
" a combination of CollisionWorld/CollisionRobot which can ve used together."
msgstr ""
"干渉検出器のタイプは、CollisionDetectorAllocatorのサブクラスであるアロケーター（へのシェアードポインター）で指定されます。"
"これは、組み合わせて使用できるCollisionWorld/CollisionRobotを指定します。"

msgid ""
"This does nothing if this type of collision detector has already been added."
msgstr "このタイプの干渉検出器が既に追加されている場合は登録しません。"

msgid ""
"A new PlanningScene contains an FCL collision detector. This FCL collision "
"detector will always be available unless it is removed by calling "
"setActiveCollisionDetector() with exclusive=true."
msgstr ""
"PlanningSceneには、デフォルトでFCL干渉検出器が含まれています。"
"このFCL干渉検出器は、exclusive = trueを指定してsetActiveCollisionDetector()を呼び出して削除しない限り、常に使用されます。"

msgid ""
"example: to add FCL collision detection (normally not necessary) call "
"planning_scene->addCollisionDetector(collision_detection::CollisionDetectorAllocatorFCL::create());"
msgstr ""
"例：FCL干渉検出を追加する（通常は必要ありません）には、planning_scene->addCollisionDetector(collision_detection::CollisionDetectorAllocatorFCL::create());を呼び出します。"

msgid ""
"Set the type of collision detector to use. Calls addCollisionDetector() to "
"add it if it has not already been added."
msgstr "使用する干渉検出器のタイプを設定します。 "
"まだ追加されていない場合は、addCollisionDetector()を呼び出して追加します。"

msgid ""
"If exclusive is true then all other collision detectors will be removed and "
"only this one will be available."
msgstr "exclusiveがtrueの場合、他のすべての干渉検出器が削除され、この検出器のみが使用されます。"

msgid ""
"example: to use FCL collision call "
"planning_scene->setActiveCollisionDetector(collision_detection::CollisionDetectorAllocatorFCL::create());"
msgstr ""
"例：FCL干渉検出器を使用するには、planning_scene->setActiveCollisionDetector(collision_detection::"
"CollisionDetectorAllocatorFCL::create());"

msgid ""
"Set the type of collision detector to use. This type must have already been "
"added with addCollisionDetector()."
msgstr "使用する干渉検出器のタイプを設定します。"
"このタイプは、addCollisionDetector()で既に追加されている必要があります。"

msgid ""
"Returns true on success, false if collision_detector_name is not the name of"
" a collision detector that has been previously added with "
"addCollisionDetector()."
msgstr ""
"成功した場合はtrue、collision_detector_nameが以前にaddCollisionDetector()で追加された干渉検出器の名前でない場合はfalseを返します。"

msgid ""
"get the types of collision detector that have already been added. These are "
"the types which can be passed to setActiveCollisionDetector()."
msgstr ""
"現在追加されている干渉検出器のタイプを取得します。"
"これらは、setActiveCollisionDetector()に渡すことができるタイプです。"

msgid "Get the representation of the world."
msgstr "ワールドの表現を取得します。"

msgid "Get the active collision detector for the world."
msgstr "ワールドのアクティブな干渉検出器を取得します。"

msgid "Get the active collision detector for the robot."
msgstr "ロボットのアクティブな干渉検出器を取得します。"

msgid ""
"Get a specific collision detector for the world. If not found return active "
"CollisionWorld."
msgstr "ワールドに特化した干渉検知器を取得します。見つからない場合は、アクティブなCollisionWorldを返します。"

msgid ""
"Get a specific collision detector for the padded robot. If no found return "
"active CollisionRobot."
msgstr "パディングされたロボット用の干渉検出器を取得します。見つからない場合は、アクティブなCollisionRobotを返します。"

msgid ""
"Get a specific collision detector for the unpadded robot. If no found return"
" active unpadded CollisionRobot."
msgstr ""
"パディングされていないロボット用の干渉検出器を取得します。見つからない場合は、アクティブなパッドなしのCollisionRobotを返します。"

msgid ""
"Get the representation of the collision robot This can be used to set "
"padding and link scale on the active collision_robot. NOTE: After modifying "
"padding and scale on the active robot call propogateRobotPadding() to copy "
"it to all the other collision detectors."
msgstr ""
"ロボットの干渉形状を取得します。"
"これを使用して、アクティブなCollisionRobotのパディングとリンクスケールを設定できます。"
"注：アクティブなロボットのパディングとスケールを変更した後、propogateRobotPadding()を呼び出して他のすべての干渉検出器にコピーする必要があります。"

msgid ""
"Copy scale and padding from active CollisionRobot to other CollisionRobots. "
"This should be called after any changes are made to the scale or padding of "
"the active CollisionRobot. This has no effect on the unpadded "
"CollisionRobots."
msgstr ""
"アクティブなCollisionRobotから他のCollisionRobotにスケールとパディングをコピーします。これは、アクティブなCollisionRobotのスケールまたはパディングに変更が加えられた後に呼び出す必要があります。これは、パディングのないCollisionRobotには影響しません。"

msgid "Get the allowed collision matrix."
msgstr "干渉行列（ACM）を取得します。"

msgid "Collision checking with respect to this planning scene"
msgstr "planning sceneに対する干渉チェック"

msgid ""
"Check if the current state is in collision (with the environment or self "
"collision). If a group name is specified, collision checking is done for "
"that group only. Since the function is non-const, the current state "
"transforms are updated before the collision check."
msgstr ""
"現在の状態が（環境または自己干渉と）干渉しているかどうかを確認します。"
"グループ名が指定されている場合、干渉チェックはそのグループに対してのみ行われます。"
"この関数はconstでないため、干渉チェックの前に現在の状態の座標変換が行われます。"

msgid ""
"Check if the current state is in collision (with the environment or self "
"collision). If a group name is specified, collision checking is done for "
"that group only. It is expected the current state transforms are up to date."
msgstr ""
"現在の状態が（環境または自己干渉と）干渉しているかどうかを確認します。"
"グループ名が指定されている場合、干渉チェックはそのグループに対してのみ行われます。"
"現在の座標変換は最新であることが期待されます。"

msgid ""
"Check if a given state is in collision (with the environment or self "
"collision) If a group name is specified, collision checking is done for that"
" group only. The link transforms for state are updated before the collision "
"check."
msgstr ""
"stateが干渉しているかどうかを確認します（環境または自己干渉）。"
"グループ名が指定されている場合、干渉チェックはそのグループに対してのみ行われます。"
"干渉チェックの前にstateに対する座標変換が行われます。"

msgid ""
"Check if a given state is in collision (with the environment or self "
"collision) If a group name is specified, collision checking is done for that"
" group only. It is expected that the link transforms of state are up to "
"date."
msgstr ""
"stateが干渉しているかどうかを確認します（環境または自己干渉）。"
"グループ名が指定されている場合、干渉チェックはそのグループに対してのみ行われます。"
"stateの座標変換は最新のものであることが期待されます。"

msgid ""
"Check if a given state is in collision (with the environment or self "
"collision) If a group name is specified, collision checking is done for that"
" group only."
msgstr ""
"stateが干渉しているかどうかを確認します（環境または自己干渉）。"
"グループ名が指定されている場合、干渉チェックはそのグループに対してのみ行われます。"

msgid ""
"Check whether the current state is in collision, and if needed, updates the "
"collision transforms of the current state before the computation."
msgstr "現在の状態が干渉しているかどうかを確認し、必要に応じて、計算の前に現在の状態の座標変換を更新します。"

msgid ""
"Check whether the current state is in collision. The current state is "
"expected to be updated."
msgstr "現在の状態が干渉しているかどうかを確認します。現在の状態は更新されることが期待されます。"

msgid ""
"Check whether a specified state (robot_state) is in collision. This variant "
"of the function takes a non-const robot_state and calls "
"updateCollisionBodyTransforms() on it."
msgstr ""
"指定された状態（robot_state）が干渉しているかどうかを確認します。このバリアントは、constではない"
"RobotStateを使ってupdateCollisionBodyTransforms()を呼び出します。"

msgid ""
"Check whether a specified state (robot_state) is in collision. The collision"
" transforms of robot_state are expected to be up to date."
msgstr ""
"指定された状態（robot_state）が干渉しているかどうかを確認します。 "
"RobotStateの座標変換は最新のものであると期待されます。"

msgid ""
"Check whether a specified state (robot_state) is in collision, with respect "
"to a given allowed collision matrix (acm). This variant of the function "
"takes a non-const robot_state and updates its link transforms if needed."
msgstr ""
"与えられた干渉行列（ACM）に関して、指定された状態（RobotState）が干渉しているかどうかを確認します。このバリアントは、constでない"
"RobotStateを取り、必要に応じて座標変換を更新します。"

msgid ""
"Check whether a specified state (robot_state) is in collision, with respect "
"to a given allowed collision matrix (acm)."
msgstr "与えられた干渉行列（ACM）に関して、指定された状態（RobotState）が干渉しているかどうかを確認します。"

msgid ""
"Check whether the current state is in collision, but use a "
"collision_detection::CollisionRobot instance that has no padding. Since the "
"function is non-const, the current state transforms are also updated if "
"needed."
msgstr ""
"パディングのないcollision_detection::CollisionRobotインスタンスを使用して現在の状態が干渉しているかどうかを確認します。"
"関数はconstでないため、必要に応じて現在の座標変換も更新されます。"

msgid ""
"Check whether the current state is in collision, but use a "
"collision_detection::CollisionRobot instance that has no padding."
msgstr ""
"パディングのないcollision_detection::CollisionRobotインスタンスを使用して現在の状態が干渉しているかどうかを確認します。"

msgid ""
"Check whether a specified state (robot_state) is in collision, but use a "
"collision_detection::CollisionRobot instance that has no padding."
msgstr ""
"パディングのないcollision_detection::CollisionRobotインスタンスを使用して指定された状態（robot_state）が干渉しているかどうかを確認します。"

msgid ""
"Check whether a specified state (robot_state) is in collision, but use a "
"collision_detection::CollisionRobot instance that has no padding. Update the"
" link transforms of robot_state if needed."
msgstr ""
"パディングのないcollision_detection::CollisionRobotインスタンスを使用して指定された状態（robot_state）が干渉しているかどうかを確認します。"
"必要に応じて、robot_stateの座標変換を更新します。"

msgid ""
"Check whether a specified state (robot_state) is in collision, with respect "
"to a given allowed collision matrix (acm), but use a "
"collision_detection::CollisionRobot instance that has no padding. This "
"variant of the function takes a non-const robot_state and calls updates the "
"link transforms if needed."
msgstr ""
"パディングのないcollision_detection::CollisionRobotインスタンスを使用して、与えられた干渉行列（ACM）に関して、指定された状態（robot_state）が干渉しているかどうかを確認します。"
"この関数のバリアントは、constでないrobot_stateを取り、必要に応じて座標変換を更新します。"

msgid ""
"Check whether a specified state (robot_state) is in collision, with respect "
"to a given allowed collision matrix (acm), but use a "
"collision_detection::CollisionRobot instance that has no padding."
msgstr ""
"パディングのないcollision_detection::CollisionRobotインスタンスを使用して、与えられた干渉行列（ACM）に関して、指定された状態（robot_state）が干渉しているかどうかを確認します。"

msgid "Check whether the current state is in self collision."
msgstr "現在の状態が自己干渉になっているかどうかを確認します。"

msgid "Check whether a specified state (robot_state) is in self collision."
msgstr "指定された状態（robot_state）が自己干渉しているかどうかを確認します。"

msgid ""
"Check whether a specified state (robot_state) is in self collision, with "
"respect to a given allowed collision matrix (acm). The link transforms of "
"robot_state are updated if needed."
msgstr ""
"与えられた干渉行列（ACM）に対して、指定された状態（robot_state）が自己干渉状態にあるかどうかを確認します。 "
"robot_stateのリンク変換は、必要に応じて更新されます。"

msgid ""
"Check whether a specified state (robot_state) is in self collision, with "
"respect to a given allowed collision matrix (acm)"
msgstr "与えられた干渉行列（ACM）に関して、指定された状態（robot_state）が自己干渉しているかどうかを確認します"

msgid ""
"Get the names of the links that are involved in collisions for the current "
"state."
msgstr "現在のstateの干渉に関係しているリンクの名前を取得します。"

msgid ""
"Get the names of the links that are involved in collisions for the state "
"robot_state. Update the link transforms for robot_state if needed."
msgstr "robot_stateの干渉に関係するリンクの名前を取得します。必要に応じて、robot_stateの座標変換を更新します。"

msgid ""
"Get the names of the links that are involved in collisions for the state "
"robot_state."
msgstr "robot_stateの干渉に関係するリンクの名前を取得します。"

msgid ""
"Get the names of the links that are involved in collisions for the state "
"robot_state given the allowed collision matrix (acm)"
msgstr "許可された干渉行列（ACM）を指定して、状態robot_stateの干渉に関係するリンクの名前を取得します"

msgid ""
"Get the names of the links that are involved in collisions for the current "
"state. Update the link transforms for the current state if needed."
msgstr "現在の状態の干渉に関係しているリンクの名前を取得します。必要に応じて、現在の状態の座標変換を更新します。"

msgid ""
"Get the names of the links that are involved in collisions for the state "
"robot_state given the allowed collision matrix (acm). Update the link "
"transforms for robot_state if needed."
msgstr ""
"許可された干渉行列（ACM）を指定して、robot_stateの干渉に関係するリンクの名前を取得します。必要に応じて、robot_stateの座標変換を更新します。"

msgid "Distance computation"
msgstr "距離計算"

msgid ""
"The distance between the robot model at state robot_state to the nearest "
"collision (ignoring self-collisions)"
msgstr "状態robot_stateのロボットモデルから最も近い干渉までの距離（自己干渉を無視）"

msgid ""
"The distance between the robot model at state robot_state to the nearest "
"collision (ignoring self-collisions), if the robot has no padding."
msgstr "ロボットにパディングがない場合、状態robot_stateのロボットモデルから最も近い干渉までの距離（自己干渉を無視）。"

msgid ""
"The distance between the robot model at state robot_state to the nearest "
"collision, ignoring self-collisions and elements that are allowed to "
"collide."
msgstr "状態robot_stateのロボットモデルから最も近い干渉までの距離。自己干渉と干渉が許可されているオブジェクトを無視します。"

msgid ""
"The distance between the robot model at state robot_state to the nearest "
"collision, ignoring self-collisions and elements that are allowed to "
"collide, if the robot has no padding."
msgstr ""
"状態robot_stateのロボットモデルから最も近い干渉までの距離。ロボットにパディングがない場合、自己干渉と干渉が許可されているオブジェクトは無視されます。"

msgid ""
"The distance between the robot model at state robot_state to the nearest "
"collision, ignoring self-collisions and elements that always allowed to "
"collide, if the robot has no padding."
msgstr ""
"状態robot_stateのロボットモデルから最も近い干渉までの距離。ロボットにパディングがない場合、自己干渉と干渉を許可されているオブジェクトを無視します。"

msgid "Public Functions"
msgstr "パブリック関数"

msgid "construct using an existing RobotModel"
msgstr "RobotModelを使用して構築します"

msgid ""
"construct using a urdf and srdf. A RobotModel for the PlanningScene will be "
"created using the urdf and srdf."
msgstr "URDFとSRDFを使用して構築します。 PlanningSceneのRobotModelは、URDFとSRDFを使用して作成されます。"

msgid "Get the name of the planning scene. This is empty by default."
msgstr "planning sceneの名前を取得します。デフォルトでは空です。"

msgid "Set the name of the planning scene."
msgstr "planning sceneの名前を設定します。"

msgid "Return a new child PlanningScene that uses this one as parent."
msgstr "これを親として使用する新しい子PlanningSceneを返します。"

msgid ""
"The child scene has its own copy of the world. It maintains a list (in "
"world_diff_) of changes made to the child world."
msgstr "子シーンには、ワールドのコピーがあります。子ワールドに加えられた変更のリスト（world_diff_内）を格納します。"

msgid ""
"The robot_model_, robot_state_, scene_transforms_, and acm_ are not copied. "
"They are shared with the parent. So if changes to these are made in the "
"parent they will be visible in the child. But if any of these is modified "
"(i.e. if the get*NonConst functions are called) in the child then a copy is "
"made and subsequent changes to the corresponding member of the parent will "
"no longer be visible in the child."
msgstr ""
"robot_model_、robot_state_、scene_transforms_、およびacm_はコピーされません。"
"それらは親と共有されます。"
"したがって、これらの変更が親で行われた場合、それらは子にも反映されます。"
"ただし、これらのいずれかが子で変更された場合（get*NonConst関数が呼び出された場合）、コピーが行われ、親の後続の変更は子に反映されなくなります。"

msgid ""
"Return a new child PlanningScene that uses this one as parent and has the "
"diffs specified by msg applied."
msgstr "このplanning sceneを親として使用し、msgで指定された差分を適用した新しい子PlanningSceneを生成します。"

msgid ""
"Get the parent scene (whith respect to which the diffs are maintained). This"
" may be empty."
msgstr "（差分の計算の対象になっている）親シーンを取得します。空の場合もあります。"

msgid "Get the kinematic model for which the planning scene is maintained."
msgstr "planning sceneが関連付けられている運動学モデルを取得します。"

msgid "Get the state at which the robot is assumed to be."
msgstr "ロボットの状態を取得します。"

msgid ""
"Get a copy of the current state with components overwritten by the state "
"message update."
msgstr "状態メッセージの更新によって上書きされた部分を含む現在の状態のコピーを取得します。"

msgid "Save the geometry of the planning scene to a stream, as plain text."
msgstr "planning sceneの形状情報をプレーンテキストとしてストリームに保存します。"

msgid "Load the geometry of the planning scene from a stream."
msgstr "ストリームからplanning sceneの形状情報を読み込みます。"

msgid ""
"Load the geometry of the planning scene from a stream at a certain location "
"using offset."
msgstr "オフセットを適用しながらストリームからplanning sceneの形状情報を読み込みます。"

msgid ""
"Fill the message scene with the differences between this instance of "
"PlanningScene with respect to the parent. If there is no parent, everything "
"is considered to be a diff and the function behaves like "
"getPlanningSceneMsg()"
msgstr ""
"このPlanningSceneインスタンスと親の差分をメッセージシーンに入力します。"
"親がない場合は、すべてが差分であると見なされ、関数はgetPlanningSceneMsg()と同様に動作します"

msgid ""
"Construct a message (scene) with all the necessary data so that the scene "
"can be later reconstructed to be exactly the same using "
"setPlanningSceneMsg()"
msgstr ""
"setPlanningSceneMsg()を使用してシーンを後で完全に再構築できるように、必要なすべてのデータを含むメッセージを作成します"

msgid ""
"Construct a message (scene) with the data requested in comp. If all options "
"in comp are filled, this will be a complete planning scene message."
msgstr ""
"compで要求されたデータを使用してメッセージを作成します。 "
"compで全てのデータが指定された場合、これは完全なplanning sceneメッセージになります。"

msgid ""
"Construct a message (collision_object) with the collision object data from "
"the planning_scene for the requested object."
msgstr ""
"指定されたオブジェクトの干渉オブジェクトデータでメッセージ（collision_object）を構築します。"

msgid ""
"Construct a vector of messages (collision_objects) with the collision object"
" data for all objects in planning_scene."
msgstr ""
"planning_scene内のすべてのオブジェクトの干渉オブジェクトデータを使用して、メッセージのリスト（collision_objects）を構築します。"

msgid ""
"Construct a message (attached_collision_object) with the attached collision "
"object data from the planning_scene for the requested object."
msgstr ""
"指定された接続されたオブジェクトの干渉オブジェクトデータを使用して、メッセージ（attached_collision_object）を作成します。"

msgid ""
"Construct a vector of messages (attached_collision_objects) with the "
"attached collision object data for all objects in planning_scene."
msgstr ""
"planning_scene内のすべての接続されたオブジェクトの干渉オブジェクトデータを使用して、メッセージのリスト（attached_collision_objects）を作成します。"

msgid ""
"Construct a message (octomap) with the octomap data from the planning_scene."
msgstr "planning_sceneのoctomapデータを使用してメッセージ（octomap）を作成します。"

msgid ""
"Construct a vector of messages (object_colors) with the colors of the "
"objects from the planning_scene."
msgstr "planning_sceneのオブジェクトの色を使って、メッセージのリスト（object_colors）を作成します。"

msgid ""
"Apply changes to this planning scene as diffs, even if the message itself is"
" not marked as being a diff (is_diff member). A parent is not required to "
"exist. However, the existing data in the planning instance is not cleared. "
"Data from the message is only appended (and in cases such as e.g., the robot"
" state, is overwritten)."
msgstr ""
"メッセージが差分（is_diff）としてマークされていない場合でも、このplanning sceneに変更を差分として適用します。"
"親は存在する必要はありません。"
"ただし、プランニングインスタンスの既存のデータはクリアされません。"
"メッセージのデータは追加されるのみです（たとえば、ロボットの状態などの場合は上書きされます）。"

msgid ""
"Set this instance of a planning scene to be the same as the one serialized "
"in the scene message, even if the message itself is marked as being a diff "
"(is_diff member)"
msgstr ""
"メッセージが差分（is_diff）としてマークされている場合でも、このインスタンスをシーンメッセージで単一にシリアル化されたものと同様に設定します。"

msgid ""
"Call setPlanningSceneMsg() or setPlanningSceneDiffMsg() depending on how the"
" is_diff member of the message is set."
msgstr ""
"メッセージのis_diffの設定に応じて、setPlanningSceneMsg()またはsetPlanningSceneDiffMsg()を呼び出します。"

msgid "Clear all collision objects in planning scene."
msgstr "planning sceneのすべての干渉オブジェクトをクリアします。"

msgid ""
"Set the current robot state to be state. If not all joint values are "
"specified, the previously maintained joint values are kept."
msgstr "現在のロボットの状態をstateに設定します。すべての関節値が指定されていない場合、以前に保存されていた関節値が保持されます。"

msgid "Set the current robot state."
msgstr "現在のロボットの状態を設定します。"

msgid ""
"Set the callback to be triggered when changes are made to the current scene "
"state."
msgstr "現在のシーンの状態に変更が加えられたときにトリガーされるコールバックを設定します。"

msgid ""
"Set the callback to be triggered when changes are made to the current scene "
"world."
msgstr "現在のシーンに変更が加えられたときにトリガーされるコールバックを設定します。"

msgid ""
"Clear the diffs accumulated for this planning scene, with respect to the "
"parent. This function is a no-op if there is no parent specified."
msgstr "親に関して、この計画シーンで蓄積された差分をクリアします。親が指定されていない場合、この関数は何もしません。"

msgid ""
"If there is a parent specified for this scene, then the diffs with respect "
"to that parent are applied to a specified planning scene, whatever that "
"scene may be. If there is no parent specified, this function is a no-op."
msgstr ""
"このシーンに親がある場合、その親に関する差分を、指定されたplanning scene（そのシーンが何であれ）に適用します。親が指定されていない場合、この関数は何もしません。"

msgid ""
"Make sure that all the data maintained in this scene is local. All "
"unmodified data is copied from the parent and the pointer to the parent is "
"discarded."
msgstr ""
"このシーンで保持されている全てのデータをローカルで保持するようにします。変更されていないデータはすべて親からコピーされ、親へのポインターが破棄されます。"

msgid ""
"Specify a predicate that decides whether states are considered valid or "
"invalid for reasons beyond ones covered by collision checking and constraint"
" evaluation. This is useful for setting up problem specific constraints "
"(e.g., stability)"
msgstr ""
"干渉チェックや制約評価でカバーされる以外の尺度で、状態の有効性を評価する関数を設定します。"
"これは、問題固有の制約（安定性など）を設定するのに役立ちます"

msgid ""
"Get the predicate that decides whether states are considered valid or "
"invalid for reasons beyond ones covered by collision checking and constraint"
" evaluation."
"干渉チェックや制約評価でカバーされる以外の尺度で、状態の有効性を評価する関数を取得します。"

msgid ""
"Specify a predicate that decides whether motion segments are considered "
"valid or invalid for reasons beyond ones covered by collision checking and "
"constraint evaluation."
msgstr ""
"干渉チェックや制約評価でカバーされる以外の尺度で、モーションセグメントの有効性を評価する関数を設定します。"

msgid ""
"Get the predicate that decides whether motion segments are considered valid "
"or invalid for reasons beyond ones covered by collision checking and "
"constraint evaluation."
msgstr ""
"干渉チェックや制約評価でカバーされる以外の尺度で、モーションセグメントの有効性を評価する関数を取得します。"

msgid ""
"Check if a given state is feasible, in accordance to the feasibility "
"predicate specified by setStateFeasibilityPredicate(). Returns true if no "
"feasibility predicate was specified."
msgstr ""
"setStateFeasibilityPredicate()で指定された評価関数に従って、指定された状態が実行可能かどうかを確認します。"
"実行可能条件が指定されていない場合はtrueを返します。"

msgid "Check if a given state satisfies a set of constraints."
msgstr "指定された状態が一連の制約を満たすかどうか確認します。"

msgid ""
"Check if a given state is valid. This means checking for collisions and "
"feasibility."
msgstr "指定された状態が有効かどうかを確認します。これは、干渉と実行可能性チェックの実施を意味します。"

msgid ""
"Check if a given state is valid. This means checking for collisions, "
"feasibility and whether the user specified validity conditions hold as well."
msgstr ""
"指定された状態が有効かどうかを確認します。"
"これは、干渉、実行可能性、およびユーザー指定の有効条件が同時に成り立つかどうかをチェックすることを意味します。"

msgid ""
"Check if a given path is valid. Each state is checked for validity "
"(collision avoidance and feasibility)"
msgstr "指定されたパスが有効かどうかを確認します。各状態の有効性がチェックされます（干渉回避と実現可能性）"

msgid ""
"Check if a given path is valid. Each state is checked for validity "
"(collision avoidance, feasibility and constraint satisfaction). It is also "
"checked that the goal constraints are satisfied by the last state on the "
"passed in trajectory."
msgstr ""
"指定されたパスが有効かどうかを確認します。各状態の妥当性（干渉回避、実現可能性、制約充足）がチェックされます。"
"また、通過した軌跡の最後の状態によってゴール制約が満たされていることも確認されます。"

msgid ""
"Check if a given path is valid. Each state is checked for validity "
"(collision avoidance, feasibility and constraint satisfaction)."
msgstr "指定されたパスが有効かどうかを確認します。各状態の妥当性（干渉回避、実現可能性、制約充足）がチェックされます。"

msgid ""
"Get the top max_costs cost sources for a specified trajectory. The resulting"
" costs are stored in costs."
msgstr "指定された軌道の上位max_costs個のコストソースを取得します。結果はcostsに保存されます。"

msgid ""
"Get the top max_costs cost sources for a specified trajectory, but only for "
"group group_name. The resulting costs are stored in costs."
msgstr ""
"グループgroup_nameについてのみ、指定された軌道の上位max_costs個のコストソースを取得します。"
"結果はcostsに保存されます。"

msgid ""
"Get the top max_costs cost sources for a specified state. The resulting "
"costs are stored in costs."
msgstr "指定した状態の上位のmax_costs個のコストソースを取得します。結果はcostsに保存されます。"

msgid ""
"Get the top max_costs cost sources for a specified state, but only for group"
" group_name. The resulting costs are stored in costs."
msgstr ""
"グループgroup_nameについてのみ、指定された軌道の上位max_costs個のコストソースを取得します。"
"結果はcostsに保存されます。"

msgid "Outputs debug information about the planning scene contents."
msgstr "planning sceneの内容に関するデバッグ情報を出力します。"

msgid "Public Static Functions"
msgstr "パブリック静的関数"

msgid ""
"Check if a message includes any information about a planning scene, or it is"
" just a default, empty message."
msgstr "メッセージにplanning sceneに関する情報が含まれているか、それが単なるデフォルトの空のメッセージであるかを確認します。"

msgid ""
"Check if a message includes any information about a planning scene world, or"
" it is just a default, empty message."
msgstr "メッセージにplanning sceneのワールドに関する情報が含まれているか、それが単なるデフォルトの空のメッセージであるかを確認します。"

msgid ""
"Check if a message includes any information about a robot state, or it is "
"just a default, empty message."
msgstr "メッセージにロボットの状態に関する情報が含まれているか、それが単なるデフォルトの空のメッセージであるかを確認します。"

msgid ""
"Clone a planning scene. Even if the scene scene depends on a parent, the "
"cloned scene will not."
msgstr "planning sceneを複製します。シーンシーンが親に依存している場合は、クローンシーンは依存しないように複製されます。"

msgid "PlanningSceneMonitor Subscribes to the topic planning_scene."
msgstr "PlanningSceneMonitorは、ROSのplanning_sceneトピックにサブスクライブし最新のシーン情報を保持します。"

msgid "Inherits from noncopyable"
msgstr ""

msgid "Constructor."
msgstr "コンストラクタ"

msgid ""
"Parameters  robot_description: The name of the ROS parameter that contains "
"the URDF (in string format)   tf_buffer: A pointer to a tf2_ros::Buffer   "
"name: A name identifying this planning scene monitor"
msgstr ""

msgid "Parameters"
msgstr "パラメータ"

msgid ""
"robot_description: The name of the ROS parameter that contains the URDF (in "
"string format)"
msgstr "robot_description：URDFを含むROSパラメーターの名前（文字列形式）"

msgid "tf_buffer: A pointer to a tf2_ros::Buffer"
msgstr "tf_buffer：tf2_ros::Bufferへのポインタ"

msgid "name: A name identifying this planning scene monitor"
msgstr "name：このplanning sceneモニターを識別する名前"

msgid ""
"Parameters  rml: A pointer to a kinematic model loader   tf_buffer: A "
"pointer to a tf2_ros::Buffer   name: A name identifying this planning scene "
"monitor"
msgstr ""

msgid "rml: A pointer to a kinematic model loader"
msgstr "rml：キネマティックモデルローダーへのポインタ"

msgid ""
"Parameters  scene: The scene instance to maintain up to date with monitored "
"information   robot_description: The name of the ROS parameter that contains"
" the URDF (in string format)   tf_buffer: A pointer to a tf2_ros::Buffer   "
"name: A name identifying this planning scene monitor"
msgstr ""
""

msgid ""
"scene: The scene instance to maintain up to date with monitored information"
msgstr "scene: モニタした情報を使って最新の状態を保持しているシーンインスタンス"

msgid ""
"Parameters  scene: The scene instance to maintain up to date with monitored "
"information   rml: A pointer to a kinematic model loader   tf_buffer: A "
"pointer to a tf2_ros::Buffer   name: A name identifying this planning scene "
"monitor"
msgstr ""

msgid ""
"Parameters  scene: The scene instance to maintain up to date with monitored "
"information   rml: A pointer to a kinematic model loader   nh: external "
"parent NodeHandle The monitors will use this NodeHandle's CallbackQueue for "
"updates. Usually, this should be a different queue than the global queue, "
"otherwise you might run into timeouts.   tf_buffer: A pointer to a "
"tf2_ros::Buffer   name: A name identifying this planning scene monitor"
msgstr ""
""

msgid ""
"nh: external parent NodeHandle The monitors will use this NodeHandle's "
"CallbackQueue for updates. Usually, this should be a different queue than "
"the global queue, otherwise you might run into timeouts."
msgstr ""
"nh: 外部の親NodeHandleモニターは、更新にこのNodeHandleのCallbackQueueを使用します。通常、これはグローバルキューとは異なるキューである必要があります。そうでない場合、タイムアウトが発生する可能性があります。"

msgid "Get the name of this monitor."
msgstr "このモニターの名前を取得します。"

msgid "Get the user kinematic model loader."
msgstr "キネマティックモデルローダーを取得します。"

msgid ""
"Avoid this function! Returns an unsafe pointer to the current planning "
"scene."
msgstr "この機能の使用は避けてください！現在のplanning sceneへの安全でないポインターを返します。"

msgid ""
"Warning  Most likely you do not want to call this function directly. "
"PlanningSceneMonitor has a background thread which repeatedly updates and "
"clobbers various contents of its internal PlanningScene instance. This "
"function just returns a pointer to that dynamic internal object. The correct"
" thing is usually to use a LockedPlanningSceneRO or LockedPlanningSceneRW, "
"which locks the PlanningSceneMonitor and provides safe access to the "
"PlanningScene object.   See  LockedPlanningSceneRO   See  "
"LockedPlanningSceneRW.   Return  A pointer to the current planning scene."
msgstr ""

msgid "Warning"
msgstr "警告"

msgid ""
"Most likely you do not want to call this function directly. "
"PlanningSceneMonitor has a background thread which repeatedly updates and "
"clobbers various contents of its internal PlanningScene instance. This "
"function just returns a pointer to that dynamic internal object. The correct"
" thing is usually to use a LockedPlanningSceneRO or LockedPlanningSceneRW, "
"which locks the PlanningSceneMonitor and provides safe access to the "
"PlanningScene object."
msgstr ""
"特殊な場合を除いて、この関数を直接呼び出しは避けてください。 "
"PlanningSceneMonitorには、内部のPlanningSceneインスタンスのさまざまなコンテンツを更新および上書きするバックグラウンドスレッドがあります。"
"この関数は、その動的内部オブジェクトへのポインタを返します。"
"この関数の代わりに、LockedPlanningSceneROまたはLockedPlanningSceneRWの使用を推奨します。"
"これにより、PlanningSceneMonitorがロックされ、PlanningSceneオブジェクトへの安全なアクセスが保障されます。"

msgid "See"
msgstr "参照"

msgid "LockedPlanningSceneRO"
msgstr "LockedPlanningSceneRO"

msgid "LockedPlanningSceneRW."
msgstr "LockedPlanningSceneRW。"

msgid "Return"
msgstr "戻り値"

msgid "A pointer to the current planning scene."
msgstr "現在のplanning sceneへのポインター。"

msgid ""
"Return true if the scene scene can be updated directly or indirectly by this"
" monitor. This function will return true if the pointer of the scene is the "
"same as the one maintained, or if a parent of the scene is the one "
"maintained."
msgstr ""
"このモニタによってシーンsceneを直接または間接的に更新できる場合は、trueを返します。"
"この関数は、シーンのポインタがこのモニタに保持されているものと同じ場合、またはシーンの親が保持されている場合にtrueを返します。"

msgid "Get the stored robot description."
msgstr "保存されたロボットの説明を取得します。"

msgid "Return  An instance of the stored robot description"
msgstr ""

msgid "An instance of the stored robot description"
msgstr "格納されたロボットデータのインスタンス"

msgid "Get the default robot padding."
msgstr "デフォルトのロボットのパディングを取得します。"

msgid "Get the default robot scaling."
msgstr "デフォルトのロボットスケーリングを取得します。"

msgid "Get the default object padding."
msgstr "デフォルトのオブジェクトのパディングを取得します。"

msgid "Get the default attached padding."
msgstr "デフォルトの接続されたパディングを取得します。"

msgid ""
"Get the instance of the TF client that was passed to the constructor of this"
" class."
msgstr "このクラスのコンストラクタに渡されたTFクライアントのインスタンスを取得します。"

msgid ""
"By default, the maintained planning scene does not reason about diffs. When "
"the flag passed in is true, the maintained scene starts counting diffs. "
"Future updates to the planning scene will be stored as diffs and can be "
"retrieved as such. Setting the flag to false restores the default behaviour."
" Maintaining diffs is automatically enabled when publishing planning scenes."
msgstr ""
"デフォルトでは、メンテナンスされた計画シーンは差分については推論しません。"
"渡されたフラグがtrueの場合、維持されているシーンは差分のカウントを開始します。"
"計画シーンの将来の更新は差分として保存され、そのように取得できます。"
"フラグをfalseに設定すると、デフォルトの動作が復元されます。"
"差分の維持は、計画シーンを公開するときに自動的に有効になります。"

msgid ""
"Start publishing the maintained planning scene. The first message set out is"
" a complete planning scene. Diffs are sent afterwards on updates specified "
"by the event bitmask. For UPDATE_SCENE, the full scene is always sent."
msgstr ""
"メンテナンスされた計画シーンの公開を開始します。最初に示されるメッセージは、完全な計画シーンです。その後、イベントビットマスクで指定された更新で差分が送信されます。"
"UPDATE_SCENEの場合、シーン全体が常に送信されます。"

msgid "Stop publishing the maintained planning scene."
msgstr "メンテナンスされた計画シーンの公開を停止します。"

msgid ""
"Set the maximum frequency at which planning scenes are being published."
msgstr "計画シーンが公開される最大頻度を設定します。"

msgid "Get the maximum frequency at which planning scenes are published (Hz)"
msgstr "計画シーンが公開される最大周波数（Hz）を取得します"

msgid "Get the stored instance of the stored current state monitor."
msgstr "保存された現在の状態モニターの保存されたインスタンスを取得します。"

msgid "Return  An instance of the stored current state monitor"
msgstr ""

msgid "An instance of the stored current state monitor"
msgstr "保存された現在の状態モニターのインスタンス"

msgid ""
"Update the transforms for the frames that are not part of the kinematic "
"model using tf. Examples of these frames are the \"map\" and "
"\"odom_combined\" transforms. This function is automatically called when "
"data that uses transforms is received. However, this function should also be"
" called before starting a planning request, for example."
msgstr ""
"tfを使用して、キネマティックモデルの一部ではないフレームの変換を更新します。これらのフレームの例は、「マップ」および「odom_combined」変換です。この関数は、変換を使用するデータが受信されると自動的に呼び出されます。ただし、この関数は、たとえば計画要求を開始する前に呼び出す必要もあります。"

msgid "Start the current state monitor."
msgstr "現在の状態モニターを開始します。"

msgid ""
"Parameters  joint_states_topic: the topic to listen to for joint states   "
"attached_objects_topic: the topic to listen to for attached collision "
"objects"
msgstr ""

msgid "joint_states_topic: the topic to listen to for joint states"
msgstr "joint_states_topic: ジョイント状態をリッスンするトピック"

msgid ""
"attached_objects_topic: the topic to listen to for attached collision "
"objects"
msgstr "attachment_objects_topic: 接続された干渉オブジェクトをリッスンするトピック"

msgid "Stop the state monitor."
msgstr "状態モニターを停止します。"

msgid ""
"Update the scene using the monitored state. This function is automatically "
"called when an update to the current state is received (if "
"startStateMonitor() has been called). The updates are throttled to a maximum"
" update frequency however, which is set by setStateUpdateFrequency()."
msgstr ""
"監視状態を使用してシーンを更新します。この関数は、現在の状態の更新を受信すると自動的に呼び出されます（startStateMonitor（）が呼び出された場合）。ただし、更新は、setStateUpdateFrequency（）によって設定される最大更新頻度に調整されます。"

msgid ""
"Update the scene using the monitored state at a specified frequency, in Hz. "
"This function has an effect only when updates from the CurrentStateMonitor "
"are received at a higher frequency. In that case, the updates are throttled "
"down, so that they do not exceed a maximum update frequency specified here."
msgstr ""
"指定された周波数（Hz）で監視状態を使用してシーンを更新します。この関数は、CurrentStateMonitorからの更新がより高い頻度で受信される場合にのみ効果があります。その場合、更新はここで指定された最大更新頻度を超えないように調整されます。"

msgid "Parameters  hz: the update frequency. By default this is 10Hz."
msgstr ""

msgid "hz: the update frequency. By default this is 10Hz."
msgstr "hz：更新頻度。デフォルトでは10Hzです。"

msgid ""
"Get the maximum frequency (Hz) at which the current state of the planning "
"scene is updated."
msgstr "計画シーンの現在の状態が更新される最大周波数（Hz）を取得します。"

msgid "Start the scene monitor."
msgstr "シーンモニターを起動します。"

msgid "Parameters  scene_topic: The name of the planning scene topic"
msgstr ""

msgid "scene_topic: The name of the planning scene topic"
msgstr "scene_topic：計画シーントピックの名前"

msgid "Request planning scene state using a service call."
msgstr "サービスコールを使用して計画シーンの状態を要求します。"

msgid ""
"Parameters  service_name: The name of the service to use for requesting the "
"planning scene. This must be a service of type moveit_msgs::GetPlanningScene"
" and is usually called \"/get_planning_scene\"."
msgstr ""

msgid ""
"service_name: The name of the service to use for requesting the planning "
"scene. This must be a service of type moveit_msgs::GetPlanningScene and is "
"usually called \"/get_planning_scene\"."
msgstr ""
"service_name：計画シーンのリクエストに使用するサービスの名前。これは、タイプmoveit_msgs :: "
"GetPlanningSceneのサービスである必要があり、通常「/ get_planning_scene」と呼ばれます。"

msgid "Stop the scene monitor."
msgstr "シーンモニターを停止します。"

msgid "Start the OccupancyMapMonitor and listening for:"
msgstr "OccupancyMapMonitorを起動して、次の情報をリッスンします。"

msgid ""
"Requests to add/remove/update collision objects to/from the world  The "
"collision map  Requests to attached/detach collision objects Parameters  "
"collision_objects_topic: The topic on which to listen for collision objects"
"   planning_scene_world_topic: The topic to listen to for world scene "
"geometry   load_octomap_monitor: Flag to disable octomap monitor if desired"
msgstr ""
"コリジョンオブジェクトをワールドに追加/削除/更新するリクエストコリジョンマップコリジョンオブジェクトをアタッチ/デタッチするリクエストパラメータcollision_objects_topic：コリジョンオブジェクトをリッスンするトピックPlanning_scene_world_topic：ワールドシーンジオメトリをリッスンするトピックload_octomap_monitor：フラグ必要に応じてoctomapモニターを無効にする"

msgid "Requests to add/remove/update collision objects to/from the world"
msgstr "コリジョンオブジェクトをワールドに追加/削除/更新するリクエスト"

msgid "The collision map"
msgstr "干渉マップ"

msgid ""
"Requests to attached/detach collision objects Parameters  "
"collision_objects_topic: The topic on which to listen for collision objects"
"   planning_scene_world_topic: The topic to listen to for world scene "
"geometry   load_octomap_monitor: Flag to disable octomap monitor if desired"
msgstr ""
"干渉オブジェクトのアタッチ/デタッチのリクエストパラメータcollision_objects_topic：干渉オブジェクトをリッスンするトピックplanning_scene_world_topic：ワールドシーンジオメトリをリッスンするトピックload_octomap_monitor：必要に応じてoctomapモニターを無効にするフラグ"

msgid ""
"collision_objects_topic: The topic on which to listen for collision objects"
msgstr "collision_objects_topic：干渉オブジェクトをリッスンするトピック"

msgid ""
"planning_scene_world_topic: The topic to listen to for world scene geometry"
msgstr "planning_scene_world_topic：ワールドシーンジオメトリをリッスンするトピック"

msgid "load_octomap_monitor: Flag to disable octomap monitor if desired"
msgstr "load_octomap_monitor：必要に応じてoctomapモニターを無効にするフラグ"

msgid "Stop the world geometry monitor."
msgstr "ワールドジオメトリモニターを停止します。"

msgid "Add a function to be called when an update to the scene is received."
msgstr "シーンの更新が受信されたときに呼び出される関数を追加します。"

msgid ""
"Clear the functions to be called when an update to the scene is received."
msgstr "シーンの更新を受信したときに呼び出される関数をクリアします。"

msgid "Get the topic names that the monitor is listening to."
msgstr "モニターがリッスンしているトピック名を取得します。"

msgid ""
"Return the time when the last update was made to the planning scene (by any "
"monitor)"
msgstr "計画シーンに最後の更新が行われた時刻を返します（モニターによって）"

msgid ""
"This function is called every time there is a change to the planning scene."
msgstr "この関数は、計画シーンが変更されるたびに呼び出されます。"

msgid "Wait for robot state to become more recent than time t."
msgstr "ロボットの状態が時間tよりも新しくなるのを待ちます。"

msgid ""
"If there is no state monitor active, there will be no scene updates. Hence, "
"you can specify a timeout to wait for those updates. Default is 1s."
msgstr ""
"アクティブな状態モニターがない場合、シーンの更新はありません。したがって、タイムアウトを指定して、それらの更新を待つことができます。デフォルトは1秒です。"

msgid ""
"Lock the scene for reading (multiple threads can lock for reading at the "
"same time)"
msgstr "読み取りのためにシーンをロックします（複数のスレッドが同時に読み取りのためにロックできます）"

msgid ""
"Unlock the scene from reading (multiple threads can lock for reading at the "
"same time)"
msgstr "読み取りからシーンのロックを解除します（複数のスレッドが同時に読み取りのためにロックできます）"

msgid ""
"Lock the scene for writing (only one thread can lock for writing and no "
"other thread can lock for reading)"
msgstr "書き込み用にシーンをロックします（1つのスレッドのみが書き込み用にロックでき、他のスレッドは読み取り用にロックできません）"

msgid ""
"Lock the scene from writing (only one thread can lock for writing and no "
"other thread can lock for reading)"
msgstr "書き込みからシーンをロックします（1つのスレッドのみが書き込みのためにロックでき、他のスレッドは読み取りのためにロックできません）"

msgid "Public Static Attributes"
msgstr "パブリック静的属性"

msgid "The name of the topic used by default for receiving joint states."
msgstr "ジョイント状態を受信するためにデフォルトで使用されるトピックの名前。"

msgid "The name of the topic used by default for attached collision objects."
msgstr "アタッチされた干渉オブジェクトにデフォルトで使用されるトピックの名前。"

msgid ""
"The name of the topic used by default for receiving collision objects in the"
" world."
msgstr "ワールドで干渉オブジェクトを受信するためにデフォルトで使用されるトピックの名前。"

msgid ""
"The name of the topic used by default for receiving geometry information "
"about a planning scene (complete overwrite of world geometry)"
msgstr "計画シーンに関するジオメトリ情報を受信するためにデフォルトで使用されるトピックの名前（ワールドジオメトリの完全な上書き）"

msgid ""
"The name of the topic used by default for receiving full planning scenes or "
"planning scene diffs."
msgstr "完全な計画シーンまたは計画シーンの差分を受信するためにデフォルトで使用されるトピックの名前。"

msgid ""
"The name of the service used by default for requesting full planning scene "
"state."
msgstr "完全な計画シーンの状態を要求するためにデフォルトで使用されるサービスの名前。"

msgid ""
"The name of the topic used by default for publishing the monitored planning "
"scene (this is without \"/\" in the name, so the topic is prefixed by the "
"node name)"
msgstr ""
"監視対象の計画シーンを公開するためにデフォルトで使用されるトピックの名前（名前に「/」がないため、トピックにはノード名が接頭辞として付けられます）"
